---
layout: post
title: "My Experience With PHP"
date: 2018-08-02
---
I used to see having zero experience with PHP as a personal accomplishment of sorts.
Despite jumping on the web development bandwagon well over a year ago, I'd never had a chance
— or a desire, really — to check the language out. Now though, having received a PHP-specific
assignment, I've decided to set my preconceptions aside and finally get a feel for the language.

## Preparing the environment

There are several ways to set up a development environment for practically any stack; one of them is through
Docker containers. There are numerous advantages to this: no implicit dependencies on system libraries,
straightforward deployment, and reduced clutter on the local machine.

I'm going to start with an _nginx_ image based on _Alpine Linux_. I've picked _nginx_ over _Apache_ because
I have some (minimal) experience with it. _Alpine Linux_ is just the distro of choice for Docker images,
being smaller in size than alternatives like _Ubuntu_.

```dockerfile
FROM nginx:1.15-alpine
```

Along with `php7`, I'll need a handful of extensions: `php7-fpm` (a FastCGI
process manager, allowing the interpreter to be run separately from the server),
`php7-phar` (PHP Archives, a distribution format for applications),
`php7-session` (sessions to persist data between requests),
`php7-xml`, `php7-xmlwriter`, and `php7-dom` (XML document manipulation tools),
and a few others:

```dockerfile
RUN apk add --no-cache php7 php7-fpm php7-phar php7-session \
      php7-xml php7-xmlwriter php7-dom php7-tokenizer \
      php7-mbstring php7-iconv php7-openssl php7-json php7-zip
```

Next to be installed is _Composer_, a PHP package manager:

```dockerfile
RUN apk add curl
RUN curl http://getcomposer.org/installer -o composer-setup.php \
 && php7 composer-setup.php --install-dir=/usr/bin --filename=composer \
 && rm composer-setup.php
```

Finally, I set a working directory for the shell inside a container
(this will come in handy in a moment):

```dockerfile
WORKDIR /src
```

The Dockerfile is ready.

`docker build -t php7-env .` builds an image tagged `php7-env` using the
Dockerfile located in the current working directory.

`docker run -it --rm -v $(pwd):/src -p 8000:8000 php7-env sh` spins up 
a container with an interactive shell (`-it`), to be cleaned up upon exit (`--rm`),
with the current working directory mounted at `/src` inside it, exposing
port `8000`, and running `sh`.

## Getting started with the app

I don't want to go the frameworkless route until I have a good sense of
what idiomatic code looks like in modern PHP, yet my assignment is quite
small, and employing a full-featured MVC framework is clearly an overkill.

[Bullet](https://github.com/vlucas/bulletphp) seems like a nice option:
it's small enough and doesn't feel too magic-y — at first sight at least.

It is installed using Composer by executing `composer install` in a directory
with a `composer.json` file, where Bullet is declared as a dependency:

```json
{
  "require": {
    "vlucas/bulletphp": "~1.7"
  }
}
```

The README for Bullet includes a sample `index.php`:

```php
<?php
require __DIR__ . '/../vendor/autoload.php';

$app = new Bullet\App();

$app->path('/', function($request) {
    return "Hello World!";
});

$app->run(new Bullet\Request())->send();
```

To make sure my setup is correct, I launch a development server,
`php -S 0.0.0.0:8000 -t src` (assuming `index.php` resides in the `src` directory).

## A (brief) dive into PHP

The first statement in the snippet above is `require`. It includes and evaluates
a script generated by Composer, which sets up PHP class autoloading — a mapping
from namespaces to source file paths.

Speaking of namespaces, PHP distinguishes between fully-qualified names (`\Bullet\App`),
which stand for the exact namespace (`Bullet\App`), and relative names (`Bullet\App`),
which have the current namespace prepended to them. In the example script,
it is unspecified (defaulting to global), making `Bullet\App` and `\Bullet\App` equivalent.

String concatenation operator `.` also deserves a mention, as it isn't immediately recognizable
coming from other scripting languages. `__DIR__` is a magic constant that stands for the directory
of the file — just like `__dir__` in Ruby.

The next line is a variable declaration, which presents me a great opportunity to finally find out
why variable names in PHP have to start with `$`. Turns out it's an imitation of Perl, which itself
was inspired by shell scripting. In PHP, it enables string interpolation without special characters
(e.g. `echo "Welcome $name!";`) and allows class variables and class functions to share the same
name (without the dollar sign in the latter case, of course).

`->` is used to access instance members, like the `path` function in the code above. Static members
are accessed using `::`, the infamous _Paamayim Nekudotayim_ (double colon) operator.

That's all I have so far — it's time to code something a bit more complex!
